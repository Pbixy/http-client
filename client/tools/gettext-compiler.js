var extract = require('./lib/extract');
var fs = require('fs');
var path = require('path');
var glob = require('glob');
var async = require('async');
var po = require('pofile');
var _ = require('lodash');

var tsDir = './src';
var poDir = './l18n';
var outputPot = './l18n/template.pot';
var outputCompiled = './src/gettext/string.service.ts';

_.each(process.argv, function (arg, i) {
    if (arg === '--ts-dir') {
        tsDir = process.argv[i + 1] || './src';
    } else if (arg === '--po-dir') {
        poDir = process.argv[i + 1] || './l18n';
    } else if (arg === '--output-pot') {
        outputPot = process.argv[i + 1] || './po/template.pot';
    } else if (arg === '--output-compiled') {
        outputCompiled = process.argv[i + 1] || './po/template.pot';
    }
});

var terms = [];
var q = async.queue(function (task, callback) {
    fs.readFile(task.file, function (err, data) {
        if (err) throw err;

        terms.push({
            file: task.file,
            terms: extract(data.toString(), task.file.substr(task.file.lastIndexOf('.') + 1))
        });

        callback();
    });
});

glob(tsDir + '/**/*.{ts,html}', function (err, files) {
    if (err) throw err;

    _.each(files, function (file) {
        q.push({file: file});
    });
});

q.drain = function () {
    var catalog = new po();

    _.each(terms, function (group) {
        _.each(group.terms, function (term) {
            var comment = group.file + ' [' + term.start.line + ':' + term.start.column + ']';
            var existing = _.find(catalog.items, function (i) {
                return i.msgid === term.term;
            });

            if (existing) {
                existing.comments.push(comment);
            } else {
                var item = new po.Item();
                item.msgid = term.term;
                item.comments = [comment];
                catalog.items.push(item);
            }
        });
    });

    catalog.headers = {
        'Content-Type': 'text/plain; charset=UTF-8',
        'Content-Transfer-Encoding': '8bit',
        'Project-Id-Version': ''
    };

    catalog.items.sort(function (a, b) {
        return a.msgid === b.msgid ? 0 : a.msgid > b.msgid ? 1 : -1;
    });

    mkdir(outputPot);

    fs.writeFile(outputPot, "", function (err) {
        if (err) throw err;

        catalog.save(outputPot, function (err) {
            if (err) throw err;

            compile();
        });
    });
};

var compile = function () {
    var strings = {};
    var q = async.queue(function (task, callback) {
        fs.readFile(task.file, function (err, data) {
            if (err) throw err;

            var catalog = po.parse(data.toString());
            strings[catalog.headers.Language] = {};

            _.each(catalog.items, function (term) {
                strings[catalog.headers.Language][term.msgid] = term.msgstr.length === 1 ? term.msgstr[0] : term.msgstr;
            });

            callback();
        });
    });

    glob(poDir + '/**/*.po', function (err, files) {
        if (err) throw err;

        _.each(files, function (file) {
            q.push({
                file: file
            });
        });
    });

    q.drain = function () {
        var service = '/** This file is automatically generated, do not edit it! **/\n\n' +
            'import {Injectable} from "@angular/core";\n\n' +
            '@Injectable()\n' +
            'export class GettextStrings {\n' +
            '    getStrings() {\n' +
            '        return ' + JSON.stringify(strings) + ';\n' +
            '    }\n' +
            '}';

        fs.writeFile(outputCompiled, service, function (err) {
            if (err) throw err;
        });
    };
};

var directoryExists = function (path) {
    try {
        return fs.statSync(path).isDirectory();
    }
    catch (err) {
        return false;
    }
};

var mkdir = function (filePath) {
    var dirname = path.dirname(filePath);
    if (directoryExists(dirname)) {
        return true;
    }
    mkdir(dirname);
    fs.mkdirSync(dirname);
};
